---
lang: fr-FR
title: Exploration des données issues de l'API de TravelTime

format:
  html:
    number-sections: true
    css: style/custom_styles.css

---


# Récupération des coordonnées des villes françaises
 
L'objectif de cette partie est de récupérer les coordonnées géographiques des gares françaises à partir d'une base de données disponible en accès ouvert sur [data.gouv.fr](https://www.data.gouv.fr/).


:::{.callout-note}
## Comment télécharger un CSV dans un programe R ?
Il suffit de copier-coller le lien de téléchargement d'un fichier CSV dans la fonction `read.csv` ou `read.csv2` (exemple : `read.csv("lien_de_téléchargement")`)
:::


::: {.callout-tip collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 2 : Travailler avec des données géographiques

1. Sur [data.gouv.fr](https://www.data.gouv.fr/), trouvez le jeu de données correspondant à la liste des gare.

2. Importez le jeu de données au format csv dans votre console R, sans télécharger localement le fichier. Observez les données.

```{r}
#| code-fold: true
#| code-summary: Cliquez pour voir la réponse
#| code-overflow: scroll
#| eval: false

# On définit l'URL des données
STATIONS_DATA_URL <- "https://www.data.gouv.fr/fr/datasets/r/d22ba593-90a4-4725-977c-095d1f654d28"

stations_data <- read.csv2(STATIONS_DATA_URL)
```

<details>
<summary>Afficher les données</summary>
</summary>

```{r}
#| echo: false
#| output: true
#| eval: true
#| df-print: kable

# On définit l'URL des données
STATIONS_DATA_URL <- "https://www.data.gouv.fr/fr/datasets/r/d22ba593-90a4-4725-977c-095d1f654d28"

stations_data <- read.csv2(STATIONS_DATA_URL)

stations_data_to_print <- stations_data |> head(6)

kableExtra::kbl(stations_data_to_print,
              "markdown",
              escape = FALSE,
              booktabs = TRUE) |>
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

``` 

</details>

3. Utiliser cette base de données qui contient, entre autres, les coordonnées géographiques des gares françaises afin d'extraire un couple de coordonnées (latitude, longitude) à partir d'un nom de gare. Faire un test en affichant les coordonnées de la gare de Lille-Flandres.

```{r}
#| code-fold: true
#| code-summary: Cliquez pour voir la réponse
#| code-overflow: scroll
#| eval: true

STATION_NAME <- "Lille-Flandres"

coords <- stations_data |>
  dplyr::select(lng = x_wgs84, lat = y_wgs84, libelle) |>
  dplyr::filter(libelle == STATION_NAME) |>
  dplyr::summarise(lat = dplyr::first(as.numeric(lat)), lng = dplyr::first(as.numeric(lng))) |>
  unlist(use.names = FALSE)
```

4. Encapsuler le code précédent dans une fonction renvoyant les coordonnées d'une gare à partir de la chaîne de caractère du nom de la gare. Faire un test en affichant les coordonnées de la gare de Toulouse-Matabiau.

```{r}
#| code-fold: true
#| code-summary: Cliquez pour voir la réponse
#| code-overflow: scroll
#| eval: true
#| lst-label: lst-get_station_coordinates
#| lst-cap: get_station_coordinates

get_station_coordinates <- function(station, data, verbose = TRUE){
  
  coords <- data |>
    dplyr::select(lng = x_wgs84, lat = y_wgs84, libelle) |>
    dplyr::filter(libelle == station) |>
    dplyr::summarise(lat = dplyr::first(as.numeric(lat)), lng = dplyr::first(as.numeric(lng))) |>
    unlist(use.names = FALSE)

  # Si verbose est TRUE, on affiche les coordonnées
  if (verbose){
    cat(sprintf("%s -> (%f, %f)\n", station, coords[1], coords[2]))
  }
  
  return(coords)
}

tlse_coords <- get_station_coordinates("Toulouse-Matabiau", stations_data)

```

::: 


# Obtention du temps de transport entre 2 villes

L'objectif de cette partie est de récupérer le temps de transport entre deux gares à partir de leur nom en combinant la fonction `get_traveltimeAPI_response()` donnée dans la fonction [get_traveltimeAPI_response()](api.qmd#lst-get_traveltimeAPI_response) et la fonction [get_station_coordinates()](#lst-get_station_coordinates).

::: {.callout-tip collapse="false" icon=false}
## `<i class="bi bi-book"></i>`{=html} Exercice 3 : Calcul du temps de transport

1. Crée une fonction qui prend en paramètres deux couples de coordonnées et qui renvoie un JSON (en chaine de caractère) destiné à l'API de routage.

```{r}
#| code-fold: true
#| code-summary: Cliquez pour voir la réponse
#| code-overflow: scroll
#| eval: true

get_routes_api_json <- function(coords1, coords2){
  # On créé le JSON pour l'API de routage en se basant sur celui de la sous-partie "Interaction avec l'API de routage de TravelTime"
  request_body <- sprintf('{
    "locations": [
      {
        "id": "point-from",
        "coords": {
          "lat": %f ,
          "lng": %f 
        }
      },
      {
        "id": "point-to-1",
        "coords": {
          "lat": %f ,
          "lng": %f 
        }
      }
    ],
    "departure_searches": [
      {
        "id": "departure-search",
        "transportation": {
          "type": "public_transport",
          "walking_time": 900,
          "cycling_time_to_station": 100,
          "parking_time": 0,
          "boarding_time": 0,
          "driving_time_to_station": 1800,
          "pt_change_delay": 0,
          "disable_border_crossing": false
        },
        "departure_location_id": "point-from",
        "arrival_location_ids": [
          "point-to-1"
        ],
        "departure_time": "2024-06-05T18:00:00.000Z",
        "properties": [
          "travel_time",
          "route"
        ],
        "range": {
          "enabled": true,
          "max_results": 5,
          "width": 43200
        }
      }
    ]
  }' , coords1[1], coords1[2], coords2[1], coords2[2])
  return(request_body)
}
```

:::

Dans un premier temps, crée une fonction qui prend en paramètre deux couples de coordonnées et qui renvoie un JSON (en chaine de caractères) destiné à l'API de routage en faisant de la concaténation de chaînes de caractères

Créer un JSON (en chaine de caractères) pour l'API de routage "routes" de TravelTime à partir de la documentation et du playground disponible [ici](https://playground.traveltime.com/routes) avec les caractéristiques ci-dessous afin qu'il servent de base pour cette fonction :

-   Lieu de départ : Variable (lat1, lng1)

-   Lieu d'arrivée : Variable (lat2, lng2)

-   Mode de transport : Transport public (bus, métro, tram, train)

-   Date et heure : 2024-06-05 à 18h00 UTC

-   Flexibilité : 12h00

-   Le reste des paramètres par défaut

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

getRoutesApiJson <- function(lat1, lng1, lat2, lng2){
  # On créé le JSON pour l'API de routage en se basant sur celui de la sous-partie "Interaction avec l'API de routage de TravelTime"
  json <- paste0('{
    "locations": [
      {
        "id": "point-from",
        "coords": {
          "lat": ', lat1, ',
          "lng": ', lng1, '
        }
      },
      {
        "id": "point-to-1",
        "coords": {
          "lat": ', lat2, ',
          "lng": ', lng2, '
        }
      }
    ],
    "departure_searches": [
      {
        "id": "departure-search",
        "transportation": {
          "type": "public_transport",
          "walking_time": 900,
          "cycling_time_to_station": 100,
          "parking_time": 0,
          "boarding_time": 0,
          "driving_time_to_station": 1800,
          "pt_change_delay": 0,
          "disable_border_crossing": false
        },
        "departure_location_id": "point-from",
        "arrival_location_ids": [
          "point-to-1"
        ],
        "departure_time": "2024-06-05T18:00:00.000Z",
        "properties": [
          "travel_time",
          "route"
        ],
        "range": {
          "enabled": true,
          "max_results": 5,
          "width": 43200
        }
      }
    ]
  }')
  return(json)
}
```

Maintenant, en utilisant la fonction précédement écrite, le but est de créer une fonction qui prend en paramètre deux noms de gares et qui renvoie le temps de transport en heure du trajet le plus court entre ces 2 gares. Il faudra prendre soin de gérer le cas où aucun trajet n'est trouvé en renvoyant *Inf*.

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

getTravelTimeBetweenStations <- function(station1, station2, verbose = TRUE){
  # On récupère les coordonnées des villes
  coordinates1 <- getStationCoordinates(station1, verbose = FALSE)
  coordinates2 <- getStationCoordinates(station2, verbose = FALSE)
  
  # On récupère le JSON pour l'API de routage
  json <- getRoutesApiJson(coordinates1[1], coordinates1[2], coordinates2[1], coordinates2[2])
  
  # On questionne l'API de routage avec le json
  response <- getTraveltimeAPIResponse(ROUTES_API_URL, json)
  
  # Si on a le code de réponse 429, on dépasse le quota de requêtes par minute
  # donc on attend 1 minute et on relance la fonction en récursion
  if (response[[2]] == 429){
    print("Trop de requêtes, on attend une minute...")
    Sys.sleep(60)
    return(getTravelTimeBetweenStations(station1, station2, verbose))
  }
  
  # Si aucun itinéraire n'a été trouvé
  if (length(response[[1]]$results[[1]]$locations) == 0){
      travelTime <- Inf
      # On affiche le temps de trajet si verbose est TRUE
      if (verbose){
        cat(station1, " -> ", station2, " : ", travelTime, "\n")
      }
      return(travelTime)
  # Sinon
  }else{
    # On extrait la liste des descriptions des itinéraires trouvés
    apiData <- response[[1]]$results[[1]]$locations[[1]]$properties
    
    # On boucle sur apiData pour récupérer les temps de trajet
    travelTimes <- c()
    for (i in 1:length(apiData)){
      # On convertit le temps de trajet en heures et on l'ajoute à travelTimes
      travelTime <- apiData[[i]]$travel_time
      travelTimes <- c(travelTimes, travelTime)
    }
    
    # On récupère l'itinéraire le plus court et on convertie le temps de trajet en heures
    travelTime <- min(travelTimes) / 3600
    
    # On affiche le temps de trajet si verbose est TRUE
    if (verbose){
      cat(station1, " -> ", station2, " : ", travelTime, "\n")
    }
    
    return(travelTime)
  }
}
```

Tester la fonction avec Paris-Montparnasse et Toulouse-Matabiau

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

travelTime <- getTravelTimeBetweenStations("Paris-Montparnasse", "Toulouse-Matabiau")
travelTime
```

Faire une matrice temporelle des temps de trajet entre les gares des 10 plus grandes agglomérations françaises (on considerera que la matrice est symétrique pour la compléter plus rapidement)

La liste des noms des gares principales (telle qu'écrite dans la base de données en opendata) des 10 plus grandes agglomérations françaises est la suivante : Paris-Nord, Lyon-Perrache, Marseille-St-Charles, Toulouse-Matabiau, Lille-Flandres, Bordeaux-St-Jean, Nice-Ville, Nantes, Strasbourg-Ville et Montpellier-St-Roch

::: callout-warning
**ATTENTION** : *L'API de routage de TravelTime a un quota de requêtes par minute :* Si la fonction *getTraveltimeAPIResponse* donnée dans la partie 1 renvoie le code *429*, cela signifie que vous avez dépassé le quota de requêtes par minute. Dans ce cas, attendez une minute avec la fonction *Sys.sleep(60)* avant de relancer la fonction précédement écrite.
:::

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

# Top 5 des gares principales des plus grandes agglomérations françaises
stations <- c("Paris-Nord", "Lyon-Perrache", "Marseille-St-Charles", "Toulouse-Matabiau", "Lille-Flandres")

# Top 10 des gares principales des plus grandes agglomérations françaises
#stations <- c("Paris-Nord", "Lyon-Perrache", "Marseille-St-Charles", "Toulouse-Matabiau", "Lille-Flandres", "Bordeaux-St-Jean", "Nice-Ville", "Nantes", "Strasbourg-Ville", "Montpellier-St-Roch")

timeMatrix <- matrix(NA, nrow = length(stations), ncol = length(stations), dimnames = list(stations, stations))

for (i in 1:length(stations)){
  for (j in 1:i){
    if (j != i){
      timeTravel <- getTravelTimeBetweenStations(stations[i], stations[j])
      timeMatrix[stations[i], stations[j]] <- timeTravel
      timeMatrix[stations[j], stations[i]] <- timeTravel
    }
  }
}

timeMatrix
```

Créer une liste avec les couples des gares reliées par un temps de trajet inférieur à 4h30

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

THRESHOLD <- 4.5

# On met les couples de gares de la matrice timeMatrix dans une liste
underThresholdRoutes <- list()
for (i in 1:length(stations)){
  for (j in 1:i){
    if (i != j){
      if (timeMatrix[i, j] < THRESHOLD){
        underThresholdRoutes[[length(underThresholdRoutes)+1]] <- c(stations[i], stations[j])
      }
    }
  }
}

underThresholdRoutes
```

# Téléchargement et traitement des données de trafic aérien entre deux villes

Cette avant dernière partie du sujet consiste à télécharger et traiter des données de trafic aérien entre deux aéroports en 2019 pour calculer les émissions de CO2 du trafic aérien entre les couples de villes/de gares identifiés précédemment et d'en déduire les émissions de CO2 approximatives évitées avec des mesures hypothétiques d'interdictions de liaisons aériennes.

Télécharger et observer les données de trafic aérien des liaisons en 2019 de la DGAC en opendata disponibles [ici](https://www.data.gouv.fr/fr/datasets/trafic-aerien-commercial-mensuel-francais-par-paire-daeroports-par-sens-depuis-1990/)

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

AIR_TRAFIC_DATA_URL <- "https://www.data.gouv.fr/fr/datasets/r/0c0a451e-983b-4f06-9627-b5ff1bccd2fc" 

airTraficDf <- read.csv2(AIR_TRAFIC_DATA_URL)

head(airTraficDf)
```

Créer une fonction qui renvoie le trafic total d'une liaison en 2019 en PKT (produit du nombre de passagers et de la distance parcourue) à partir des deux noms de villes (et non d'aéroport) en paramètre

-   Les noms des principaux aéroports de métropole contiennent le nom de la ville qu'il déssert
-   Le nombre de passagers est dans le champ *LSN_PAX_loc*

::: callout-note
**Note** : Les noms des principaux aéroports de métropole contiennent le nom de la ville qu'il déssert
:::

::: callout-note
**Note** : Le nombre de passagers correspond au champ *LSN_PAX_loc*
:::

::: callout-warning
**ATTENTION** : Prendre en compte le trafic aérien dans les deux sens
:::

::: callout-warning
**ATTENTION** : Paris qui possède 2 aéroports
:::

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

getAirTraficBetweenCities <- function(city1, city2){
  
  # Trafic dans le sens city1 -> city2
  airTrafic1 <- airTraficDf %>%
             filter(grepl(city1, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city2, LSN_ARR_NOM, ignore.case = TRUE)) %>%
    summarise(trafic = sum(LSN_DIST*LSN_PAX_loc))
  
  # Trafic dans le sens city2 -> city1
  airTrafic2 <- airTraficDf %>%
             filter(grepl(city2, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city1, LSN_ARR_NOM, ignore.case = TRUE)) %>%
    summarise(trafic = sum(LSN_DIST*LSN_PAX_loc))
  
  return(as.numeric(airTrafic1 + airTrafic2))
}
```

Tester la fonction avec Paris et Toulouse (Il faut trouver 1 870 474 245 PKT)

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

trafic <- getAirTraficBetweenCities("Paris", "Toulouse")
trafic
```

Sommer le trafic aérien pour chaque couple de villes reliées par un temps de trajet inférieur à 4h30

::: callout-note
**Note** : Les noms des principales gares de métropole contiennent le nom de la ville qu'il déssert
:::

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

underThresholdAirTrafic <- 0
for (route in underThresholdRoutes){
  # On utilise strsplit pour récupérer le nom de la ville associé à une gare
  city1 <- strsplit(route[1], "-")[[1]][1]
  city2 <- strsplit(route[2], "-")[[1]][1]
  airTrafic <- getAirTraficBetweenCities(city1, city2)
  underThresholdAirTrafic <- underThresholdAirTrafic + airTrafic
}
underThresholdAirTrafic
```

En déduire les émissions de CO2 approximatives évitées que représente ce trafic avec une estimation des gCO2éq par PKT de [statista](https://www.statista.com/statistics/1113177/co2-emissions-by-airline-europe/)

**CHUNK DE CODE A ECRIRE**

```{r}
#| echo: FALSE
#| class-output: output

GCO2_PER_PKT <- 80

# On estime les émissions de CO2 en tCO2éq
underThresholdEmissions <- underThresholdAirTrafic * GCO2_PER_PKT / 1000000
underThresholdEmissions
```

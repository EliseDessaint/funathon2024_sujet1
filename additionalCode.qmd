# Code annexe

## 2.Récupération des coordonnées des villes françaises

### OPTION 1 : osmdata

On utilise le package "osmdata" de OpenStreetMap pour récupérer les coordonnées des villes françaises qui nous intéressent

```{r}
library(osmdata)

CITY_NAME <- "Lille"

# On obtient les coordonnées de la ville
coordinates <-  rowMeans(getbb(paste0(CITY_NAME,", France")))
coordinates

# On constate que la latitude et la longitude sont inversées, on les inverse
coordinates <- rev(coordinates)
names(coordinates) <- c("lat", "lng")
coordinates

```

On fait une fonction qui renvoie les coordonnées d'une ville à partir de son nom

```{r}
getCityCoordinates <- function(city, verbose = TRUE){
  # On obtient les coordonnées de la ville
  coordinates <-  rowMeans(getbb(paste0(city,", France")))
  # On constate que la latitude et la longitude sont inversées, on les inverse
  coordinates <- rev(coordinates)
  names(coordinates) <- c("lat", "lng")
  # Si verbose est TRUE, on affiche les coordonnées
  if (verbose){
    cat(city, " -> (", coordinates[1],", ",coordinates[2], ")\n", sep = "")
  }
  return(coordinates)
}
```

### OPTION 2 : tmaptools

On utilise le package "tmaptools" pour récupérer les coordonnées des villes françaises qui nous intéressent

```{r}
library(tmaptools)

CITY_NAME <- "Lille"

# On obtient les coordonnées de la ville
coords <- geocode_OSM(CITY_NAME)
print(coords)

# On constate que la latitude et la longitude sont inversées, on les inverse
coords <- rev(coords$coords)
names(coords) <- c("lat", "lng")
coords
```

On fait une fonction qui renvoie les coordonnées d'une ville à partir de son nom

```{r}
getCityCoordinates <- function(city, verbose = TRUE){
  # On obtient les coordonnées de la ville
  coordinates <-  geocode_OSM(city)
  # On constate que la latitude et la longitude sont inversées, on les inverse
  coordinates <- rev(coordinates$coords)
  names(coordinates) <- c("lat", "lng")
  # Si verbose est TRUE, on affiche les coordonnées
  if (verbose){
    cat(city, " -> (", coordinates[1],", ",coordinates[2], ")\n", sep = "")
  }
  return(coordinates)
}
```

## Interaction avec l'API d'isochrones de TravelTime

On créé un JSON (en chaine de caractères) pour l'API "isochrones" de TravelTime à partir de la documentation et du playground disponible [ici](https://playground.traveltime.com/isochrones) avec les caractéristiques suivantes :

-   Lieu : Centre de Paris (48.8534, 2.3483)

-   Isochrone : 1h00

-   Mode de transport : Transport public (bus, métro, tram, train)

-   Date et heure : 2024-04-05 à 18h00 UTC

-   Flexibilité : 1h00

-   Le reste des paramètres par défaut

```{r}
json <- '{
  "departure_searches": [
    {
      "id": "isochrone-0",
      "coords": {
        "lat": 48.8534,
        "lng": 2.3483
      },
      "departure_time": "2024-04-05T18:00:00.000Z",
      "travel_time": 3600,
      "transportation": {
        "type": "public_transport",
        "walking_time": 900,
        "cycling_time_to_station": 100,
        "parking_time": 0,
        "boarding_time": 0,
        "driving_time_to_station": 1800,
        "pt_change_delay": 0,
        "disable_border_crossing": false
      },
      "level_of_detail": {
        "scale_type": "simple",
        "level": "medium"
      },
      "single_shape": false,
      "no_holes": false,
      "range": {
        "enabled": true,
        "width": 3600
      }
    }
  ]
}'
```

On teste l'API avec la fonction et le json, et on regarde le contenu de la réponse de l'API

```{r}
ISOCHRONE_API_URL <- "https://api.traveltimeapp.com/v4/time-map"

response <- getTraveltimeAPIResponse(ISOCHRONE_API_URL, json)
#View(response) # Ne marche pas pour les rendus Quarto
response
```

Après observation du contenu de la réponse, on extrait les données utiles de celui-ci

```{r}
apiData <- response[[1]]$results[[1]]$shapes
#View(apiData) # Ne marche pas pour les rendus Quarto
apiData # Très long à afficher dans les rendus Quarto
```

Après observation des données, on extrait le premier polygone de l'isochrone

```{r}
# On extrait le premier polygone de l'isochrone
rawShape1 <- apiData[[1]]$shell
# On initialise un dataframe vide
shape1 <- data.frame(lat = numeric(), lng = numeric())
# On parcourt chaque élément de rawShape1 pour le transformer en dataframe
for(currentPoint in rawShape1) {
  # On ajoute les coordonnées du point courant à shape1
  shape1 <- rbind(shape1, data.frame(lat = currentPoint$lat, lng = currentPoint$lng))
}
shape1
```

On extrait tous les polygones de l'isochrone dans une liste en faisant une boucle du code précédent

```{r}
shapeList <- list()
# On boucle sur chaque polygone de l'isochrone
for (i in 1:length(apiData)){
  
  
  # On extrait le n-ième polygone de l'isochrone
  rawShape <- response[[1]]$results[[1]]$shapes[[i]]$shell
  # On initialise un dataframe vide
  shape <- data.frame(lat = numeric(), lng = numeric())
  # On parcourt chaque élément de rawShape pour le transformer en dataframe
  for(currentPoint in rawShape) {
    # On ajoute les coordonnées du point courant à shape
    shape <- rbind(shape, data.frame(lat = currentPoint$lat, lng = currentPoint$lng))
  }
  
  
  # On ajoute le polygone à la liste
  shapeList[[length(shapeList)+1]] <- shape
}
```

## Affichage de la carte et de l'isochrone avec le package leaflet

On entre la clé API de Stadia Maps (créér un compte [ici](https://client.stadiamaps.com/signup/?utm_content=top_nav_signup&utm_source=marketing_site)) et on entre les liens des tuiles Stadia Maps pour les fonds de carte (autres URL de fonds de carte [ici](https://stadiamaps.com/themes/))

```{r}
library(leaflet)

STADIA_MAPS_API_KEY <- yaml::read_yaml("config.yaml")$stadiaMaps$API_KEY

ALIDADE_SMOOTH_TILES_URL <- "https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png?api_key="
OUTDOORS_TILES_URL <- "https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.png?api_key="
ALIDADE_SATELLITE_TILES_URL <- "https://tiles.stadiamaps.com/tiles/alidade_satellite/{z}/{x}/{y}{r}.png?api_key="

# On passe la clé API dans les URL des tuiles
TILES_URL <- paste0(ALIDADE_SMOOTH_TILES_URL, STADIA_MAPS_API_KEY)

```

On créé une carte de base avec le fond de carte Stadia Maps

```{r}
leafletMap <- leaflet() %>%
  addTiles(urlTemplate = TILES_URL)

```

On boucle pour ajouter chaque polygone de shapeList à la carte

```{r}
for (s in shapeList) {
  leafletMap <- leafletMap %>% addPolygons(data = s, 
                                           ~lng, ~lat, 
                                           color = "#FF0000", 
                                           fillColor = "#FFAAAA", 
                                           fillOpacity = 0.5, 
                                           weight = 2)
}
```

On affiche la carte

```{r}
leafletMap
```

## Interaction avec l'API de matrices temporelles de TravelTime

On crée un JSON (en chaine de caractères) pour l'API "travel time distance matrix" de TravelTime à partir de la documentation et du playground disponible [ici](https://playground.traveltime.com/travel-time-distance-matrix) avec les caractéristiques suivantes :

-   Lieu de départ : Paris (48.8534, 2.3483)

-   Lieux d'arrivées : Lille (50.6365, 3.0635), Lyon (45.7578, 4.8320), Marseille (43.2965, 5.3698), Bordeaux (44.8378, -0.5792) et Toulouse (43.6044, 1.4442)

-   Durée maximum : 4h00

-   Mode de transport : Transport public (bus, métro, tram, train)

-   Date et heure : 2024-04-05 à 18h00 UTC

-   Flexibilité : 12h00

-   Le reste des paramètres par défaut

```{r}
json <- '{
  "locations": [
    {
      "id": "starting-location",
      "coords": {
        "lat": 48.8534,
        "lng": 2.3483
      }
    },
    {
      "id": "lille",
      "coords": {
        "lat": 50.6365,
        "lng": 3.0635
      }
    },
    {
      "id": "lyon",
      "coords": {
        "lat": 45.7578,
        "lng": -4.8320
      }
    },
    {
      "id": "marseille",
      "coords": {
        "lat": 43.2965,
        "lng": -5.3698
      }
    },
    {
      "id": "bordeaux",
      "coords": {
        "lat": 44.8378,
        "lng": -0.5792
      }
    },
    {
      "id": "toulouse",
      "coords": {
        "lat": 43.6044,
        "lng": 1.4442
      }
    }
  ],
  "departure_searches": [
    {
      "id": "Departure search",
      "arrival_location_ids": [
        "lille",
        "lyon",
        "marseille",
        "bordeaux",
        "toulouse"
      ],
      "departure_location_id": "starting-location",
      "departure_time": "2024-04-05T18:00:00.000Z",
      "travel_time": 14400,
      "properties": [
        "travel_time"
      ],
      "transportation": {
        "type": "public_transport",
        "walking_time": 900,
        "cycling_time_to_station": 100,
        "parking_time": 0,
        "boarding_time": 0,
        "driving_time_to_station": 1800,
        "pt_change_delay": 0,
        "disable_border_crossing": false
      },
      "range": {
        "enabled": true,
        "width": 43200,
        "max_results": 1
      }
    }
  ]
}'
```

On questionne l'API avec la fonction et le json, et on regarde le contenu de la réponse de l'API

```{r}
TIME_MATRIX_API_URL <- "https://api.traveltimeapp.com/v4/time-filter"

response <- getTraveltimeAPIResponse(TIME_MATRIX_API_URL, json)
#View(response) # Ne marche pas pour les rendus Quarto
response # Très long à afficher dans les rendus Quarto
```

Après observation du contenu de la réponse, on extrait les données utiles de celui-ci

```{r}
apiData <- response[[1]]$results[[1]]
#View(apiData) # Ne marche pas pour les rendus Quarto
apiData # Très long à afficher dans les rendus Quarto
```

## Morceau de code pour un affichage plus proprement des données JSON de taille importante reçu par les API

```{r}
library(jsonlite)

# Fonction pour tronquer les listes JSON pour les rendre plus lisibles
troncateJson <- function(json, maxPrintedElements = 8) {
  if(is.list(json)) {
    # Application récursive pour les sous-listes
    json <- lapply(json, troncateJson, maxPrintedElements = maxPrintedElements)
    # Troncature de la liste avec indication si nécessaire
    if(length(json) > maxPrintedElements) {
      json <- json[1:maxPrintedElements]
      # Ajout d'un objet spécifique pour indiquer la troncature
      json[["@@@LISTE"]] <- "TRONQUEE@@@"
    }
  }
  return(json)
}

# Modification de la fonction prettyJson pour inclure un nombre maximal de lignes à afficher
prettyJson <- function(json, maxLines = 100, maxPrintedElements = 8) {
  troncatedJson <- troncateJson(json, maxPrintedElements = maxPrintedElements)
  troncatedJsonString <- toJSON(troncatedJson, pretty = TRUE)
  # On limite le nombre de lignes affichées à maxLines
  jsonLines <- unlist(strsplit(troncatedJsonString, "\n"))
  if(length(jsonLines) > maxLines) {
    jsonLines <- head(jsonLines, maxLines)
    jsonLines <- c(jsonLines, "...")
  }
  cat(paste(jsonLines, collapse = "\n"))
  return(paste(jsonLines, collapse = "\n"))
}
```

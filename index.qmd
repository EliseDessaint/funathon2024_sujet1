---
title: "Visualisation des émissions de C02 de liaisons aériennes"
subtitle: "Visualiser les émissions de C02 liées à une mesure de restriction de liaison aérienne relativement à des durées de trajets ferroviaires"
format:
  html:
    toc: true
    number-sections: true
editor: visual
editor_options: 
  chunk_output_type: console
---

## Objectifs

Visualiser les émissions de C02 liées à une mesure de restriction de liaison aérienne relativement à des durées de trajets ferroviaires dans le cadre. L'étude portera sur les liaisons aériennes entre les 10 plus grandes agglomérations de la Métropole française. Elle permettra de quantifier et de localiser les émissions de C02 évitées avec des mesures hypothétiques d'interdictions de liaisons aériennes lorsqu'une alternative ferroviaire existe en moins de 3h30, 4h30, 5h30...

En travaillant sur ce sujet vous apprendrez à :

-   Interroger l'API de [TravelTime](https://traveltime.com/) pour obtenir des données de temps de trajet
-   Utiliser des données de trafic aérien pour calculer des émissions de C02
-   Créer une carte interactive avec le package leaflet et des fonds de carte de [Stadia Maps](https://stadiamaps.com/)

## Déroulement du sujet

1.  Interaction avec l'API de routage de TravelTime
2.  Récupération des coordonnées des villes françaises
3.  Obtention du temps de transport entre 2 villes
4.  Téléchargement et traitement des données de trafic aérien entre 2 aéroports
5.  Datavisualisation des données sur une carte avec le package leaflet

## Rappel sur l'utilisation d'un document quarto

Dans ce sujet nous vous proposons d'utiliser un document quarto qui est le successeur de Rmarkdown. Le principe est de mélanger du texte (Markdown) et des bouts de code que l'on appelle des **chunks** (code R, Python, Observable...). Le bouton *Render* permet de produire un document en exécutant les chunks et en transformant le markdown en texte mis en forme. Les formats de sortie sont html, pdf, docx, présentation...

Rstudio propose 2 manières de consulter/modifier un doc quarto :\
- Visual : aide à la saise du Markdown et de création des chunks - Source : que du code, moins facile à prendre en main mais plus *pur*

Les chunks doivent être nommées et des paramètres peuvent être précisées, voir ici : https://quarto.org/docs/computations/r.html

En haut à droite de chaque chunk vous avez 2 boutons. Le premier permet de rejouer tous les chunks qui précèdent le chunk. L'autre permet de jouer le chunk (possible aussi en faisant CTRL + MAJ + ENTREE avec le curseur dans le chunk).

Nous vous proposons de travailler dans les chunks proposés et d'en créer d'autres à votre guise. Attention chaque chunk doit avoir un nom unique. Pensez à faire régulièrement un *Render* afin de vous assurer que votre code complet compile bien.

## Configuration de notre script

La première étape en Quarto est de créer un *chunk* de setup qui télécharge et installe les packages nécessaires au bon déroulement de ce sujet (*httr*, *yaml*, *osmdata*, *tmaptools*, *dplyr*, *leaflet* et *jsonlite*)

*Chunk de code qui sera donnée aux participants*

```{r}
# Installation des packages nécessaires indiqué dans le fichier DESCRIPTION
devtools::install_deps()
```

## 1.Interaction avec l'API de routage de TravelTime

La première partie du sujet consiste à interroger basiquement l'API de routage de TravelTime qui permet obtenir des données de temps de trajet entre deux points définis par leurs coordoonées géographiques.

Les deux prochains chunks de code vous sont donnés, ils permettent l'envoie d'une requête contenant un JSON à l'endpoint (i.e au lien) d'une API de TravelTime afin de récupérer les données de temps de trajet.

::: {note}
**Note** : *Qu'est ce qu'une API ?* C'est une interface logicielle (Application Programming Interface) qui permet à des applications de communiquer entre elles. Ces interfaces utilisent en général des requêtes HTTP contenant des JSON pour envoyer et recevoir des données.
:::

Commencer par créer un compte sur [TravelTime](https://account.traveltime.com/) afin de pouvoir accéder à leur API via des clés API.

Créer ensuite un fichier de configuration "config.yaml" structuré comme ci-dessous pour stocker les clés API :

``` yaml
travelTime:
  X_API_ID: "votre_id_api_ici"
  X_API_KEY: "votre_clé_api_ici"
```

::: {note}
**Note** : *Qu'est ce qu'un fichier yaml ?* C'est un format de fichier simplifié qui permet de stocker des données structurées à la manière d'un fomart CSV, JSON ou XML. Il est souvent utilisé pour stocker des configurations de programme.
:::

On teste ensuite l'envoie d'une requête HTTP contenant un JSON à l'endpoint (i.e au lien) d'une API de TravelTime grâce au code fourni.

Pour cela, à partir de la documentation et du playground de l'API de routage disponible [ici](https://playground.traveltime.com/routes) :

-   compléter la variable *ROUTES_API_URL* du chunk ci-dessous par l'endpoint de l'API de routage
-   compléter la variable *json* du chunk ci-dessous par JSON de test (en chaine de caractères) pour l'API de routage

Tester l'API et observer le contenu et le code de la réponse grâce au chunk de code fourni ci-dessous.

*Chunk de code qui sera donnée aux participants (à l'exception des variables ROUTES_API_URL et json)*

```{r}
library(httr)
library(yaml)

# On lit les clés API dans le fichier de configuration
secrets <- yaml::read_yaml("config.yaml")
X_API_ID <- secrets$travelTime$X_API_ID
X_API_KEY <- secrets$travelTime$X_API_KEY

# On copie-colle l'endpoint de l'API de routage
ROUTES_API_URL <- "https://api.traveltimeapp.com/v4/routes"

# On copie-colle un JSON de test du playground de l'API de routage
json <- '{
  "locations": [
    {
      "id": "point-from",
      "coords": {
        "lat": 48.8534,
        "lng": 2.3483
      }
    },
    {
      "id": "point-to-1",
      "coords": {
        "lat": 43.6044,
        "lng": 1.4442
      }
    }
  ],
  "departure_searches": [
    {
      "id": "departure-search",
      "transportation": {
        "type": "public_transport",
        "walking_time": 900,
        "cycling_time_to_station": 100,
        "parking_time": 0,
        "boarding_time": 0,
        "driving_time_to_station": 1800,
        "pt_change_delay": 0,
        "disable_border_crossing": false
      },
      "departure_location_id": "point-from",
      "arrival_location_ids": [
        "point-to-1"
      ],
      "departure_time": "2024-05-05T18:00:00.000Z",
      "properties": [
        "travel_time",
        "route"
      ],
      "range": {
        "enabled": true,
        "max_results": 5,
        "width": 43200
      }
    }
  ]
}'


# On prépare l'entête de la requête
headers <- httr::add_headers("Content-Type" = "application/json",
                             "X-Application-Id" = X_API_ID,
                             "X-Api-Key" = X_API_KEY)
# On envoie la requête avec les headers spécifiés
response <- httr::POST(ROUTES_API_URL, body = json, encode = "json", headers)
# On récupère le contenu de la réponse
content <- httr::content(response)
# On récupère le code de la réponse
code <- httr::status_code(response)

#View(content) # Ne marche pas pour les rendus Quarto
content # Très long à afficher dans les rendus Quarto
code
```

On encapsule le code précédent dans une fonction qui envoie une requête contenant un JSON (en chaine de caractères) à l'endpoint d'une API de TravelTime et qui renvoie le contenu et le code de la réponse de l'API

*Chunk de code qui sera donnée aux participants*

```{r}
getTraveltimeAPIResponse <- function(apiUrl, json){
  # On prépare les headers
  headers <- httr::add_headers("Content-Type" = "application/json",
                               "X-Application-Id" = X_API_ID,
                               "X-Api-Key" = X_API_KEY)
  # On envoie la requête avec les headers spécifiés
  response <- httr::POST(apiUrl, body = json, encode = "json", headers)
  # On récupère le contenu de la réponse
  content <- httr::content(response)
  # On récupère le code de la réponse
  code <- httr::status_code(response)
  return(list(content, code))
}
```

Tester la fonction *getTraveltimeAPIResponse* avec l'endpoint et le json de test précédents et analyser le contenu de la réponse de l'API

```{r}
response <- getTraveltimeAPIResponse(ROUTES_API_URL, json)
#View(response) # Ne marche pas pour les rendus Quarto
response # Très long à afficher dans les rendus Quarto
```

Après analyse du contenu de la réponse, extraire les données utiles de celui-ci

```{r}
apiData <- response[[1]]$results[[1]]$locations[[1]]$properties
#View(apiData) # Ne marche pas pour les rendus Quarto
apiData # Très long à afficher dans les rendus Quarto
```

## 2.Récupération des coordonnées des villes françaises

Le but de la seconde partie du sujet est de récupérer les coordonnées géographiques des gares de gares françaises à partir d'une base de données publique.

Utiliser la base de donnée publique de [data.gouv.fr](https://www.data.gouv.fr/fr/datasets/liste-des-gares/) qui contient (entre autres) les coordonnées géographiques des gares françaises afin d'extraire un couple de coordonnées (latitude, longitude) à partir d'un nom de gare.

::: {note}
**Note** : *Comment télécharger un CSV dans un programe R ?* Il suffit de copier-coller le lien de téléchargement d'un fichier CSV dans la fonction *read.csv* ou *read.csv2* (exemple : *read.csv("lien_de_téléchargement")*)
:::

```{r}
library(dplyr)

# On charge les données
STATIONS_DATA_URL <- "https://www.data.gouv.fr/fr/datasets/r/d22ba593-90a4-4725-977c-095d1f654d28" 

stationsData <- read.csv2(STATIONS_DATA_URL)

STATION_NAME <- "Lille-Flandres"

# On conserve et on renomme les données utiles
stationsData <- stationsData %>% 
  select(libelle, commune, x_wgs84, y_wgs84) %>% 
  rename("lng" = x_wgs84, "lat"=y_wgs84)

# On obtient les coordonnées de la gare
stationData <- stationsData %>% 
  filter(libelle == STATION_NAME)

# On converti et on ordonne les coordonnées
coords <- c(as.numeric(stationData$lat[1]),as.numeric(stationData$lng[1]))
coords
```

Encapsuler le code précédent dans une fonction renvoyant les coordonnées d'une gare à partir de la chaîne de caractères du nom de la gare

```{r}
getStationCoordinates <- function(station, verbose = TRUE){
  
  # Cas particulier pour Strasbourg-Ville
  if (station == "Strasbourg-Ville"){
    coords <- c(48.584488, 7.735626)
  # Cas général
  }else{
    data <- stationsData %>% 
      filter(libelle == station)
    coords <- c(as.numeric(data$lat[1]),as.numeric(data$lng[1]))
  }
  
  # Si verbose est TRUE, on affiche les coordonnées
  if (verbose){
    cat(station, " -> (", coords[1],", ",coords[2], ")\n", sep = "")
  }
  
  return(coords)
}
getStationCoordinates("Toulouse-Matabiau")
```

## 3.Obtention du temps de transport entre 2 villes

L'objectif de la partie 3 est de récupérer le temps de transport entre deux gares à partir de leur nom en combinant la fonction *getTraveltimeAPIResponse* donnée dans la partie 1 et la fonction créée en partie 2

Dans un premier temps, crée une fonction qui prend en paramètre deux couples de coordonnées et qui renvoie un JSON (en chaine de caractères) destiné à l'API de routage en faisant de la concaténation de chaînes de caractères

Crée un JSON (en chaine de caractères) pour l'API de routage "routes" de TravelTime à partir de la documentation et du playground disponible [ici](https://playground.traveltime.com/routes) avec les caractéristiques ci-dessous afin qu'il servent de base pour cette fonction :

-   Lieu de départ : Variable (lat1, lng1)

-   Lieu d'arrivée : Variable (lat2, lng2)

-   Mode de transport : Transport public (bus, métro, tram, train)

-   Date et heure : 2024-05-05 à 18h00 UTC

-   Flexibilité : 12h00

-   Le reste des paramètres par défaut

```{r}
getRoutesApiJson <- function(lat1, lng1, lat2, lng2){
  # On créé le JSON pour l'API de routage en se basant sur celui de la sous-partie "Interaction avec l'API de routage de TravelTime"
  json <- paste0('{
    "locations": [
      {
        "id": "point-from",
        "coords": {
          "lat": ', lat1, ',
          "lng": ', lng1, '
        }
      },
      {
        "id": "point-to-1",
        "coords": {
          "lat": ', lat2, ',
          "lng": ', lng2, '
        }
      }
    ],
    "departure_searches": [
      {
        "id": "departure-search",
        "transportation": {
          "type": "public_transport",
          "walking_time": 900,
          "cycling_time_to_station": 100,
          "parking_time": 0,
          "boarding_time": 0,
          "driving_time_to_station": 1800,
          "pt_change_delay": 0,
          "disable_border_crossing": false
        },
        "departure_location_id": "point-from",
        "arrival_location_ids": [
          "point-to-1"
        ],
        "departure_time": "2024-05-05T18:00:00.000Z",
        "properties": [
          "travel_time",
          "route"
        ],
        "range": {
          "enabled": true,
          "max_results": 5,
          "width": 43200
        }
      }
    ]
  }')
  return(json)
}
```

Maintenant, en utilisant la fonction précédement écrite, créer une fonction qui prend en paramètre deux noms de gares et qui renvoie le temps de transport en heure du trajet le plus court entre ces 2 gares. Il faudra prendre soin de gérer le cas où aucun trajet n'est trouvé en renvoyant *Inf*.

```{r}
getTravelTimeBetweenStations <- function(station1, station2, verbose = TRUE){
  # On récupère les coordonnées des villes
  coordinates1 <- getStationCoordinates(station1, verbose = FALSE)
  coordinates2 <- getStationCoordinates(station2, verbose = FALSE)
  
  # On récupère le JSON pour l'API de routage
  json <- getRoutesApiJson(coordinates1[1], coordinates1[2], coordinates2[1], coordinates2[2])
  
  # On questionne l'API de routage avec le json
  response <- getTraveltimeAPIResponse(ROUTES_API_URL, json)
  
  # Si on a le code de réponse 429, on dépasse le quota de requêtes par minute
  # donc on attend 1 minute et on relance la fonction en récursion
  if (response[[2]] == 429){
    print("Trop de requêtes, on attend une minute...")
    Sys.sleep(60)
    return(getTravelTimeBetweenStations(station1, station2, verbose))
  }
  
  # Si aucun itinéraire n'a été trouvé
  if (length(response[[1]]$results[[1]]$locations) == 0){
      travelTime <- Inf
      # On affiche le temps de trajet si verbose est TRUE
      if (verbose){
        cat(station1, " -> ", station2, " : ", travelTime, "\n")
      }
      return(travelTime)
  # Sinon
  }else{
    # On extrait les données utiles
    apiData <- response[[1]]$results[[1]]$locations[[1]]$properties
    
    # On boucle sur apiData pour récupérer les temps de trajet
    travelTimes <- c()
    for (i in 1:length(apiData)){
      # On convertit le temps de trajet en heures et on l'ajoute à travelTimes
      travelTime <- apiData[[i]]$travel_time
      travelTimes <- c(travelTimes, travelTime)
    }
    
    # On récupère l'itinéraire le plus court et on convertie le temps de trajet en heures
    travelTime <- min(travelTimes) / 3600
    
    # On affiche le temps de trajet si verbose est TRUE
    if (verbose){
      cat(station1, " -> ", station2, " : ", travelTime, "\n")
    }
    
    return(travelTime)
  }
}
```

Tester la fonction avec Paris-Montparnasse et Toulouse-Matabiau

```{r}
travelTime <- getTravelTimeBetweenStations("Paris-Montparnasse", "Toulouse-Matabiau")
travelTime
```

Faire une matrice temporelle des temps de trajet entre les gares des 10 plus grandes agglomérations françaises (on considerera que la matrice est symétrique pour la compléter plus rapidement)

La liste des noms des gares principales (telle qu'écrite dans la base de données publique) des 10 plus grandes agglomérations françaises est la suivante : Paris-Nord, Lyon-Perrache, Marseille-St-Charles, Toulouse-Matabiau, Lille-Flandres, Bordeaux-St-Jean, Nice-Ville, Nantes, Strasbourg-Ville et Montpellier-St-Roch

::: {ATTENTION}
**ATTENTION** : *L'API de routage de TravelTime a un quota de requêtes par minute :* Si la fonction *getTraveltimeAPIResponse* donnée dans la partie 1 renvoie le code *429*, cela signifie que vous avez dépassé le quota de requêtes par minute. Dans ce cas, attendez une minute avec la fonction *Sys.sleep(60)* avant de relancer la fonction précédement écrite.
:::

```{r}
# Top 5 des gares principales des plus grandes agglomérations françaises
stations <- c("Paris-Nord", "Lyon-Perrache", "Marseille-St-Charles", "Toulouse-Matabiau", "Lille-Flandres")

# Top 10 des gares principales des plus grandes agglomérations françaises
#stations <- c("Paris-Nord", "Lyon-Perrache", "Marseille-St-Charles", "Toulouse-Matabiau", "Lille-Flandres", "Bordeaux-St-Jean", "Nice-Ville", "Nantes", "Strasbourg-Ville", "Montpellier-St-Roch")

timeMatrix <- matrix(NA, nrow = length(stations), ncol = length(stations), dimnames = list(stations, stations))

for (i in 1:length(stations)){
  for (j in 1:i){
    if (j != i){
      timeTravel <- getTravelTimeBetweenStations(stations[i], stations[j])
      timeMatrix[stations[i], stations[j]] <- timeTravel
      timeMatrix[stations[j], stations[i]] <- timeTravel
    }
  }
}

timeMatrix
```

Créer une liste avec les couples des gares reliées par un temps de trajet inférieur à 4h30

```{r}
THRESHOLD <- 4.5

# On met les couples de gares de la matrice timeMatrix dans une liste
underThresholdRoutes <- list()
for (i in 1:length(stations)){
  for (j in 1:i){
    if (i != j){
      if (timeMatrix[i, j] < THRESHOLD){
        underThresholdRoutes[[length(underThresholdRoutes)+1]] <- c(stations[i], stations[j])
      }
    }
  }
}

underThresholdRoutes
```

## 4.Téléchargement et traitement des données de trafic aérien entre 2 aéroports

On télécharge les données de trafic aérien des liaisons en 2019 de la DGAC en opendata [ici](https://www.data.gouv.fr/fr/datasets/trafic-aerien-commercial-mensuel-francais-par-paire-daeroports-par-sens-depuis-1990/)

```{r}
library(dplyr)

AIR_TRAFIC_DATA_URL <- "https://www.data.gouv.fr/fr/datasets/r/0c0a451e-983b-4f06-9627-b5ff1bccd2fc" 

airTraficDf <- read.csv2(AIR_TRAFIC_DATA_URL)

head(airTraficDf)
```

On crée une fonction qui renvoie le trafic total d'une liaison en 2019 en PKT à partir de deux noms de villes (et non d'aéroport) en paramètre (Les noms des principaux aéroports de métropole contiennent le nom de la ville qu'il déssert)

```{r}
getAirTraficBetweenCities <- function(city1, city2){
  
  # Trafic dans le sens city1 -> city2
  airTrafic1 <- airTraficDf %>%
             filter(grepl(city1, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city2, LSN_ARR_NOM, ignore.case = TRUE)) %>%
    summarise(trafic = sum(LSN_DIST*LSN_PAX_loc))
  
  # Trafic dans le sens city2 -> city1
  airTrafic2 <- airTraficDf %>%
             filter(grepl(city2, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city1, LSN_ARR_NOM, ignore.case = TRUE)) %>%
    summarise(trafic = sum(LSN_DIST*LSN_PAX_loc))
  
  return(as.numeric(airTrafic1 + airTrafic2))
}
```

On teste la fonction avec Paris et Toulouse

```{r}
trafic <- getAirTraficBetweenCities("Paris", "Toulouse")
trafic
```

On somme le trafic aérien pour chaque couple de villes reliées par un temps de trajet inférieur à 2h30 (Les noms des principales gares de métropole contiennent le nom de la ville qu'il déssert)

```{r}
underThresholdAirTrafic <- 0
for (route in underThresholdRoutes){
  # On utilise strsplit pour récupérer le nom de la ville associé à une gare
  city1 <- strsplit(route[1], "-")[[1]][1]
  city2 <- strsplit(route[2], "-")[[1]][1]
  airTrafic <- getAirTraficBetweenCities(city1, city2)
  underThresholdAirTrafic <- underThresholdAirTrafic + airTrafic
}
underThresholdAirTrafic
```

On calcule les émissions de CO2 que représente ce trafic avec une estimation des gCO2éq par PKT de [statista](https://www.statista.com/statistics/1113177/co2-emissions-by-airline-europe/)

```{r}
GCO2_PER_PKT <- 80

# On estime les émissions de CO2 en tCO2éq
underThresholdEmissions <- underThresholdAirTrafic * GCO2_PER_PKT / 1000000
underThresholdEmissions
```

## 5.Datavisualisation des données sur une carte avec le package leaflet

Commencer par créer un compte sur [Stadia Maps](https://client.stadiamaps.com/signup/?utm_content=top_nav_signup&utm_source=marketing_site) afin de pouvoir accéder à leur API via des clés API. Compléter ensuite un fichier de configuration "config.yaml" comme ci-dessous pour stocker la clé API :

``` yaml
stadiaMaps:
  API_KEY: "votre_clé_api_ici"
```

On met dans des variables globales la clé API de Stadia Maps et les liens des tuiles Stadia Maps pour les fonds de carte (URL de fonds de carte [ici](https://stadiamaps.com/themes/))

```{r}
library(leaflet)

STADIA_MAPS_API_KEY <- yaml::read_yaml("config.yaml")$stadiaMaps$API_KEY

ALIDADE_SMOOTH_TILES_URL <- "https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png?api_key="
OUTDOORS_TILES_URL <- "https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.png?api_key="
ALIDADE_SATELLITE_TILES_URL <- "https://tiles.stadiamaps.com/tiles/alidade_satellite/{z}/{x}/{y}{r}.png?api_key="

# On passe la clée API dans les URL des tuiles
TILES_URL <- paste0(ALIDADE_SMOOTH_TILES_URL, STADIA_MAPS_API_KEY)
```

On crée un dataframe avec tous les éléments pour cartographier les émissions sur les lignes repérées (les noms, les latitudes et les longitudes des villes de départ et d'arrivée, et les émissions de CO2 des lignes associées)

```{r}
emissionByRouteDf <- data.frame(city1 = character(), city2 = character(), lat1 = numeric(), lng1 = numeric(), lat2 = numeric(), lng2 = numeric(), emissions = numeric())

for (route in underThresholdRoutes){
  # On récupère les coordonnées des villes
  coordinates1 <- getStationCoordinates(route[1], verbose = FALSE)
  coordinates2 <- getStationCoordinates(route[2], verbose = FALSE)
  
  # On utilise strsplit pour récupérer le nom de la ville associé à une gare
  city1 <- strsplit(route[1], "-")[[1]][1]
  city2 <- strsplit(route[2], "-")[[1]][1]
  
  # On récupère les émissions de CO2 associées
  emissions <- getAirTraficBetweenCities(city1, city2) * GCO2_PER_PKT / 1000000
  
  # On ajoute les données au dataframe
  dfTemp <- data.frame(city1 = city1, city2 = city2,
                       lat1 = coordinates1[1], lng1 = coordinates1[2],
                       lat2 = coordinates2[1], lng2 = coordinates2[2],
                       emissions = emissions, row.names = paste0(city1, "-", city2))
  
  emissionByRouteDf <- rbind(emissionByRouteDf, dfTemp)
}

emissionByRouteDf
```

On créé une carte de base avec le fond de carte Stadia Maps

```{r}
leafletMap <- leaflet() %>%
  addTiles(urlTemplate = TILES_URL)
```

On boucle pour ajouter toutes les lignes repérées à la carte :

-   Si les émissions sont non-nulles, on les affiche en rouge avec une épaisseur de trait proportionnelle aux émissions

-   Si les émissions sont nulles, on les affiche en noir en trait fin

```{r}
for (i in 1:nrow(emissionByRouteDf)) {
  # Si les émissions sont non-nulles
  if (emissionByRouteDf[i,"emissions"] > 0){
      leafletMap <- leafletMap %>%
      addPolylines(lat = c(emissionByRouteDf[i,"lat1"], emissionByRouteDf[i,"lat2"]),
                   lng = c(emissionByRouteDf[i,"lng1"], emissionByRouteDf[i,"lng2"]),
                   weight = emissionByRouteDf[i,"emissions"]/10000,
                   color = "red", opacity = 0.5
                   )
  # Si les émissions sont nulles
      }else{
    leafletMap <- leafletMap %>%
      addPolylines(lat = c(emissionByRouteDf[i,"lat1"], emissionByRouteDf[i,"lat2"]),
                   lng = c(emissionByRouteDf[i,"lng1"], emissionByRouteDf[i,"lng2"]),
                   weight = 1,
                   color = "black", opacity = 0.5
                   )
  }
}
```

On boucle pour ajouter toutes les villes repérées à la carte

```{r}

# On personnalise les étiquettes qui seront affichées sur la carte
customLabelOptions <- labelOptions(noHide = TRUE, style = list("background" = "rgba(255, 255, 255, 0.5)"))

for (i in 1:nrow(emissionByRouteDf)) {
  leafletMap <- leafletMap %>%
    addCircleMarkers(lat = emissionByRouteDf[i, "lat1"],
                     lng = emissionByRouteDf[i, "lng1"],
                     radius = 5,
                     color = "#4444AA",
                     label = as.character(emissionByRouteDf[i, "city1"]),
                     labelOptions = customLabelOptions) %>%
    addCircleMarkers(lat = emissionByRouteDf[i, "lat2"],
                     lng = emissionByRouteDf[i, "lng2"],
                     radius = 5,
                     color = "#4444AA",
                     label = as.character(emissionByRouteDf[i, "city2"]),
                     labelOptions = customLabelOptions)
}

```

On affiche la carte

```{r}
leafletMap
```
